######
# This file includes the code to output a private confidence interval, using private mean 
# and variance estimators generated by Algorithm 6 Centered quantiles and simulation
# as introduced in Algorithm 3. 
######

#install.packages("rmutil")
#install.packages("here")
library(rmutil)

############
# The function priv_exp_ci() takes up to 7 parameters and returns a differentially private
# confidence interval: 
#   db:     Normally distributed sample data as a vector of numbers. 
#   a:      Significance level (set a = 0.05, the function outputs 95% confidence interval).
#   e:      Privacy parameter epsilon.
#   xmin:   Given lower bound of the data range.
#   xmax:   Given upper bound of the data range.
#   b:      Choice of quantile for standard deviation estimate. Set in default to the optimized value. 
#   p:      Allocation of the privacy parameter epsilon. 100p% of the privacy budget is consumed
#             by generating the private mean; the rest is consumed by generating the private
#             variance. Set in default to the optimized value. 
############
priv_exp_ci = function(rep, db, a, e, xmin, xmax, b = 0.65) {
  
  # python setup
  reticulate::use_condaenv(condaenv = "r-reticulate", conda = "auto", required = TRUE)
  
  sys <- reticulate::import("sys", convert = FALSE)
  sys$path$insert(0L, 'dp-code/quantile-functions/')
  
  joint_exp <- reticulate::source_python(file = here::here("dp-code", "quantile-functions", "joint_exp.py"))
  gcpy <- reticulate::import(module = "gc")
  
  
  n = length(db)
  db = sort(db)
  ###
  ## begin python part
  ## requires joint_exp and dependencies
  ###
  output = py$joint_exp(db, data_low = xmin, data_high = xmax, qs = c(0.5, b), eps = e, swap = TRUE)
  m = output[1]
  top = output[2]
  ###
  ## end python part
  ###
  std = max(0, (top - m) / qnorm(b))
  
  sims = 1:1000
  for(i in 1:1000) {
    sim_db = rnorm(n, m, std)
    ###
    ## begin python part
    ## requires joint_exp and dependencies
    ###
    sim_output = py$joint_exp(sim_db, xmin, xmax, as.list(0.5), e / 2, TRUE)
    sims[i] = sim_output
    ###
    ## end python part
    ###
  }
  
  moe = diff(as.double(quantile(sims, c(a / 2, 1 - a / 2)))) / 2
  return(c(m - moe, m + moe))
}
