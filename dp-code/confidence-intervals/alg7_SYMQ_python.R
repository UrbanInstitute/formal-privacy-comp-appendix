######
# This file includes the code to output a private confidence interval, using private mean 
# and variance estimators generated by Algorithm 7 Symmetric quantiles and simulation
# as introduced in Algorithm 3. 
######

#install.packages("rmutil")
#install.packages("here")
library(rmutil)

############
# The function priv_exp_ci() takes up to 6 parameters and returns a differentially private
# confidence interval: 
#   db:     Normally distributed sample data as a vector of numbers. 
#   a:      Significance level (set a = 0.05, the function outputs 95% confidence interval).
#   e:      Privacy parameter epsilon.
#   xmin:   Given lower bound of the data range.
#   xmax:   Given upper bound of the data range.
#   b:      Choice of the lower quantile. The upper quantile will be indicated by 1-b. 
#           (e.g. If want to use the first and third quartiles, do b = 0.25). Set in default
#           to the optimized value. 
############
priv_double_ci = function(rep, db, a, e, xmin, xmax, b = 0.35) {
  
  # python setup
  reticulate::use_condaenv(condaenv = "r-reticulate", conda = "auto", required = TRUE)
  
  sys <- reticulate::import("sys", convert = FALSE)
  sys$path$insert(0L, 'dp-code/quantile-functions/')
  
  joint_exp <- reticulate::source_python(file = here::here("dp-code", "quantile-functions", "joint_exp.py"))
  gcpy <- reticulate::import(module = "gc")
  

  n = length(db)
  db = sort(db)
  ###
  ## begin python part
  ## requires joint_exp and dependencies
  ###
  output = py$joint_exp(
    db, 
    data_low = xmin, 
    data_high = xmax,
    qs = c(b, 1 - b), 
    eps = e, 
    swap = TRUE
  )
  bottom = output[1]
  top = output[2]
  ###
  ## end python part
  ###
  m = (bottom + top) / 2
  std = max(0, (top - m) / qnorm(1 - b))
  
  sims = 1:1000
  for(i in 1:1000) {
    sim_db = sort(rnorm(n, m, std))
    ###
    ## begin python part
    ## requires joint_exp and dependencies
    ###
    sim_output = py$joint_exp(
      sim_db, 
      data_low = xmin, 
      data_high = xmax, 
      qs = c(b, 1 - b), 
      eps = e, 
      swap = TRUE
    )
    sim_bottom = sim_output[1]
    sim_top = sim_output[2]
    ###
    ## end python part
    ###
    sims[i] = (sim_bottom + sim_top) / 2
  }
  moe = diff(as.double(quantile(sims, c(a / 2, 1 - a / 2)))) / 2
  return(c(m - moe, m + moe))
}
